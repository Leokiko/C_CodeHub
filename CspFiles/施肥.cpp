//春天到了，西西艾弗岛上的n块田地需要施肥了。n块田地编号为1,2,3,…,n，按按编号从大到小排成一列
//为了给田地施肥，顿顿准备了m辆施肥车。但是由于土地的松软程度不同，施肥车的质量不一，不一定每一辆施肥车都能给每一块田地施肥。其中，第i辆施肥车只能恰好从第l[i]
//块田地开到第r[i]块田地，并给编号在[l[i],r[i]]之间的田地（包含l[i]和r[i]）都施一遍肥。其中1<l[i]≤r[i]<n。
//顿顿希望制定一个施肥的计划。首先，他将选定二元组 (l,r) ，并选择只给编号在 l 和 r 之间（包含 l 和 r ）的田地施肥。接着，他会从使用这辆施肥车中的一部分（或全部）对田地施肥。他想要保证：编号在 l 和 r 之内的田地至少被某一辆施肥车施了一次肥，且编号范围外的田地都没有被施过肥。	
//现在，他想知道，他能够选择多少种不同的二元组(L,R)作为施肥范围，使得可以选出一部分（或全部）施肥车，完成他的目标。
//输入描述:
//第一行两个整数n,m，表示田地的数量和施肥车的数量。
//接下来m行，每行两个整数l[i],r[i]，表示第i辆施肥车的施肥范围。
//输出描述:
//输出一个整数，表示可以选择的二元组数量。
//示例1
//输入
//3 2
//1 2
//2 3
//输出
//4
//说明
//可以选择的二元组为(1,1),(1,2),(2,2),(2,3)。
//示例2
//输入
//3 2
//1 2
//1 3
//输出
//3
//说明
//可以选择的二元组为(1,1),(1,2),(1,3)。
//示例3
//输入
//3 2
//1 2
//3 3
//输出
//2
//说明
//可以选择的二元组为(1,1),(3,3)。
//备注:
//对于30%的数据，1≤n,m≤1000
//对于100%的数据，1≤n,m≤105，1≤l[i]≤r[i]≤n

//思路：先将所有的区间按照左端点从小到大排序，然后从左到右遍历所有的区间，如果当前区间的左端点大于上一个区间的右端点，那么就可以选择这个区间，否则就不能选择这个区间。
//因为如果当前区间的左端点小于等于上一个区间的右端点，那么这两个区间就有重叠，如果选择了当前区间，那么就会导致上一个区间的右端点被施肥，而上一个区间的右端点是不能被施肥的，所以不能选择当前区间。
//时间复杂度：O(nlogn)，空间复杂度：O(n)。

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
	int n, m;
	cin >> n >> m;
	vector<pair<int, int>> v(m);
	for (int i = 0; i < m; ++i)
	{
		cin >> v[i].first >> v[i].second;
	}
	sort(v.begin(), v.end());
	int res = 0;
	int pre = 0;
	for (int i = 0; i < m; ++i)
	{
		if (v[i].first > pre)
		{
			res += v[i].second - v[i].first + 1;
			pre = v[i].second;
		}
		else if (v[i].second > pre)
		{
			res += v[i].second - pre;
			pre = v[i].second;
		}
	}
	cout << res << endl;
	return 0;
}
